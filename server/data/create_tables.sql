BEGIN;

-- Petit rappel : un table en BDD c'est TOUJOURS en snake_case, au singulier, en anglais
DROP TABLE IF EXISTS "user", "list", "card", "tag", "card_has_tag";

CREATE TABLE "user" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "email" TEXT NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "password" TEXT NOT NULL
);

-- Comme on est dans une transatcion et que l'on a drop les tables avant, ici pas besoin de veérifier l'existance de la table, on en est sûr. Car la transaction nous assure que tout c'est bien passé précédemment.
-- ! Attention il faut créer la table "list" en premier car on en aura besoin pour y faire référence dans la table "card"
CREATE TABLE "list" (
    -- GENERATED … IDENTITY sert à cérer une colonne dont la valeur sera incrémentaire de façon sequentielle automatiquement pas PG
    -- L'option BY DEFAULT permet si on le souhaite de spécifier nous même la valeur de cette colonne lors d'un insertion
    -- En règle si l'on ne fait pas de SEEDING on n'utilise ALWAYS, sinon on utilisera BY DEFAULT
    "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- En postgreSQL on utilise toujours TEXT et pas VARCHAR ou CHAR
    "name" TEXT NOT NULL,
    "position" integer NOT NULL DEFAULT 0,
        -- Comme c'est une association 1:N le champ ne peut pas être null
    -- Lorsque l'on défini qu'une colonne fait référence à une autre, PG va automatiquement créer une contrainte de clé étrangère, on a pas besoin de la créer nous même. Sauf si on veut lui donner un non particulier
    "user_id" integer NOT NULL REFERENCES "user"("id")ON DELETE CASCADE,
    -- Permet de suivre l'évolution d'un enregistrement
    "created_at" timestamptz NOT NULL DEFAULT now(),
    "updated_at" timestamptz
);

CREATE TABLE "card" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "description" text NOT NULL,
    "position" integer NOT NULL DEFAULT 0,
    "color" text,
    -- Comme c'est une association 1:N le champ ne peut pas être null
    -- Lorsque l'on défini qu'une colonne fait référence à une autre, PG va automatiquement créer une contrainte de clé étrangère, on a pas besoin de la créer nous même. Sauf si on veut lui donner un non particulier
    "list_id" int NOT NULL REFERENCES "list"("id") ON DELETE CASCADE,
    "created_at" timestamptz NOT NULL DEFAULT now(),
    "updated_at" timestamptz
);

CREATE TABLE "tag" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- on peut rajouter une contrainte d'unicité pour n'importe quel colonne d'une table, il suffit de préciser UNIQUE au même titre que NOT NULL
    "name" text NOT NULL UNIQUE,
    "color" text NOT NULL DEFAULT '#ffffff',
    "created_at" timestamptz NOT NULL DEFAULT now(),
    "updated_at" timestamptz
);

-- ! Attention il faut créer cette table après "card" et "tag" car on va faire références a ces 2 tables
CREATE TABLE "card_has_tag" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- Afin de pouvoir supprimer une carte sans avoir d'erreur de contrainte, on précise que l'on veut qu'il supprime aussi touts les enregistrement de cette table qui pourrait correspondre à l'id dfe la carte supprimée (ON DELETE CASCADE)
    "card_id" int NOT NULL REFERENCES "card"("id") ON DELETE CASCADE,
    "tag_id" int NOT NULL REFERENCES "tag"("id") ON DELETE CASCADE,
    "created_at" timestamptz NOT NULL DEFAULT now(),
    "updated_at" timestamptz
);

COMMIT;